#include "bits/stdc++.h"
using namespace std;
using ll = long long;

/*
=====================================================
Sliding Window Minimum using Min-Queue (AggQueue)
=====================================================

PROBLEM:
--------
Given an array of n numbers (generated by a recurrence)
and a window size k, compute the minimum of every
contiguous subarray (window) of size k,
then XOR all such minimums.

APPROACH:
---------
This solution implements a special data structure
called a "Min-Queue" using two "Min-Stacks".

A Min-Stack is a normal stack where each element stores:
    (value, minimum_so_far)
This allows O(1) access to the minimum element in that stack.

A Min-Queue is built from two Min-Stacks:
    - 'in'  stack: handles all incoming pushes
    - 'out' stack: handles pops (oldest elements)

To pop from the queue:
    If 'out' is empty, move all elements from 'in' to 'out'.
    This reverses their order, restoring FIFO behavior.
    (Each element moves at most once → amortized O(1))

Querying the minimum of the queue:
    If both stacks have elements,
        the queue-min = min(in.min, out.min)

SLIDING WINDOW MINIMUM:
-----------------------
1. Insert the first k elements into the Min-Queue.
2. The current minimum = mq.query()
3. For each next element arr[i]:
       mq.push(arr[i])     // add new element to the window
       mq.pop()            // remove the oldest element
       record mq.query()   // window minimum
4. XOR all window minimums.

WHY THIS STRUCTURE?
-------------------
This technique is ideal when:
    - You need sliding window minimums/maximums
    - n can be very large (up to millions)
    - You want O(n) total time, NOT O(n log k)
      → faster than using a multiset or priority queue
    - You want constant memory per element

COMPLEXITY:
-----------
Time:  O(n) amortized
Space: O(k)

WHEN TO USE:
------------
Use this pattern when you need:
    - Sliding window minimum
    - Sliding window maximum
    - Sliding window aggregate values using invertible operators

It is especially useful for:
    - Competitive programming (speed-critical)
    - Huge input constraints (n up to 10^7)
    - Replacing multiset (O(log k)) with faster O(1) amortized

=====================================================
*/


struct AggStack {
    stack<pair<ll, ll>> st;    // (value, current_min)
    
    void push(ll x) {
        ll cur = st.empty() ? x : min(st.top().second, x);
        st.push({x, cur});
    }
    
    void pop() {
        st.pop();
    }
    
    ll agg() const {
        return st.top().second;
    }
    
    bool empty() const {
        return st.empty();
    }
};

struct AggQueue {  
    AggStack in, out;
    
    void push(ll x) {
        in.push(x);
    }
    
    void pop() {
        if (out.empty()) {
            while (!in.empty()) {
                ll v = in.st.top().first;
                in.pop();
                out.push(v);
            }
        }
        out.pop();
    }
    
    ll query() const { 
        if (in.empty()) return out.agg();
        if (out.empty()) return in.agg();
        return min(in.agg(), out.agg());
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    ll n, k;
    cin >> n >> k;

    ll x, a, b, c;
    cin >> x >> a >> b >> c;

    vector<ll> arr(n);
    arr[0] = x;
    for (ll i = 1; i < n; ++i)
        arr[i] = (a * arr[i - 1] + b) % c;

    AggQueue mq;
    vector<ll> ans;

    // first window
    for (ll i = 0; i < k; i++)
        mq.push(arr[i]);

    ans.push_back(mq.query());

    // sliding
    for (ll i = k; i < n; i++) {
        mq.push(arr[i]);
        mq.pop();
        ans.push_back(mq.query());
    }

    ll res = 0;
    for (ll v : ans)
        res ^= v;

    cout << res << "\n";
    return 0;
}
